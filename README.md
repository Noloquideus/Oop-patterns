# Порождающие паттерны (Generative Patterns)

В данном репозитории представлены реализации различных порождающих паттернов, которые являются одним из типов паттернов проектирования. Порождающие паттерны предоставляют механизмы для создания объектов, скрывая детали их создания и обеспечивая гибкость в процессе создания.

## Абстрактная фабрика (Abstract Factory)

Абстрактная фабрика позволяет создавать семейства связанных или зависимых объектов без указания их конкретных классов. Она предоставляет интерфейс для создания объектов каждого семейства и обеспечивает согласованность их создания.

## Фабричный метод (Factory Method)

Фабричный метод - это паттерн проектирования, который предоставляет интерфейс для создания объектов, но позволяет подклассам решать, какой класс создавать. Это полезный паттерн, когда у вас есть общий интерфейс, но различные реализации объектов, которые могут быть созданы.

## Прототип (Prototype)

Прототип позволяет создавать объекты путем копирования уже существующего объекта-прототипа. Он предоставляет способ создания объектов без указания их конкретного класса и позволяет избежать дополнительных накладных расходов на создание объектов с нуля.

## Строитель (Builder)

Строитель позволяет создавать сложные объекты пошагово. Он абстрагирует процесс создания объекта, позволяя создавать различные представления одного и того же объекта.

## Одиночка (Singleton)

Одиночка гарантирует, что класс имеет только один экземпляр, и предоставляет глобальную точку доступа к этому экземпляру. Он обеспечивает контроль над созданием и доступом к экземпляру класса.

## Пул одиночек (Singleton Pool)

Пул одиночек предоставляет пул объектов одиночек, чтобы эффективно управлять их созданием и использованием. Он позволяет повторно использовать одиночки для различных задач и уменьшает накладные расходы на создание и удаление объектов.

## Пул объектов (Object Pool)

Пул объектов предоставляет пул предварительно созданных объектов, которые могут быть повторно использованы. Он позволяет избежать накладных расходов на создание и удаление объектов путем их повторного использования.

## Ленивая инициализация (Lazy Initialization)

Ленивая инициализация откладывает создание объекта до момента его фактического использования. Это позволяет избежать ненужных накладных расходов на создание объектов, которые могут не понадобиться.

## Реестр (Registry)

Реестр (или реестр объектов) - это паттерн проектирования, который предоставляет механизм для регистрации, поиска и получения объектов в централизованном месте. Реестр может быть использован для хранения и доступа к различным объектам приложения, таким как сервисы, компоненты и другие ресурсы.

## Локатор служб (Service Locator)

Локатор служб (или сервис-локатор) - это паттерн проектирования, который предоставляет механизм для поиска и получения служб (или сервисов) в централизованном месте. Локатор служб позволяет клиентскому коду получать доступ к службам, не зная их конкретных реализаций или деталей создания.

## Внедрение зависимости (Dependency injection)

Это паттерн проектирования, который позволяет разделить создание и конфигурацию объектов от их использования. Вместо того, чтобы объекты создавали свои зависимости, они получают их из внешнего источника, такого как контейнер внедрения зависимостей.


# Структурные паттерны (Structural patterns)
## Адаптер (Adapter)

 Адаптер это структурный паттерн, который позволяет объектам с несовместимыми интерфейсами работать вместе.

## Мост (Bridge)
Мост — это структурный паттерн, который разделяет абстракцию и реализацию так, чтобы они могли изменяться независимо друг от друга.

## Компоновщик (Composite)
Компоновщик — это структурный паттерн, который позволяет сгруппировать объекты в древовидные структуры и работать с ними так, как будто это единичный объект.

## Декоратор (Decorator)
Декоратор — это структурный паттерн, который позволяет добавлять объектам новые функциональные возможности на лету, оборачивая их в полезные «обёртки».

## Фасад (Facade)
Фасад — это структурный паттерн, который предоставляет простой интерфейс к сложной системе классов, библиотеке или фреймворку.

## Контроллер (Front Controller)
Контроллер — это архитектурный паттерн, который предоставляет единый точку входа для обработки запросов и управления его обработкой.

## Легковес (Flyweight)
Легковес — это структурный паттерн, который позволяет эффективно поддерживать огромное количество мелких объектов, используя разделение их общего состояния.

## Заместитель (Proxy)
Заместитель — это структурный паттерн, который позволяет создать объект-заместитель для контроля доступа к другому объекту или для добавления дополнительной логики при его использовании.

## Монада (Monad)
 Monad - это структурный паттерн проектирования, который позволяет комбинировать операции с помощью монадической последовательности. Он позволяет обрабатывать результаты вычислений в функциональном программировании и управлять побочными эффектами.

# Поведенческие паттерны (Behavioral patterns)

## Chain of responsibility

Паттерн Цепочка обязанностей позволяет создать цепочку объектов-обработчиков, в которой каждый объект может обработать запрос самостоятельно или передать его дальше по цепочке. Это позволяет избежать жесткой связанности между отправителем запроса и его получателем, и дает возможность гибко настраивать обработку запросов.

## Command

Паттерн Команда превращает запросы в объекты, что позволяет передавать их как аргументы, хранить их в структурах данных, выполнять отложенные или отменяемые операции. Этот паттерн используется для инкапсуляции запроса в объект, позволяя таким образом параметризовать клиентов с разными запросами, обрабатывать запросы с разными операциями и поддерживать отмену операций.

## Interpreter

Паттерн Интерпретатор определяет представление грамматики и интерпретатор для этой грамматики. Он позволяет интерпретировать предложения на определенном языке или представлять их в виде структур данных. Этот паттерн полезен, когда нужно создавать простые языки для решения определенных задач.

## Iterator

Паттерн Итератор предоставляет способ последовательного доступа к элементам коллекции без раскрытия ее внутреннего представления. Он позволяет обходить элементы коллекции без знания о ее структуре и реализации. Этот паттерн упрощает работу с коллекциями и обеспечивает единый интерфейс для их перебора.

## Mediator

Паттерн Посредник определяет объект, который инкапсулирует способ взаимодействия между объектами, позволяя им обмениваться информацией через посредника. Это позволяет снизить связанность между объектами, улучшить их повторное использование и обеспечить гибкость взаимодействия.

## Memento

Паттерн Хранитель позволяет сохранять и восстанавливать состояние объекта без нарушения инкапсуляции. Он используется для реализации механизма отката или сохранения состояния объекта, чтобы можно было восстановить его позднее.

## Observer

Паттерн Наблюдатель определяет отношение "один ко многим" между объектами, где изменение состояния одного объекта автоматически оповещает и обновляет все зависимые объекты. Этот паттерн позволяет объектам быть независимыми друг от друга, но в то же время реагировать на изменения состояния друг друга.

## Blackboard (Доска объявлений)

Паттерн Доска объявлений используется для решения сложных проблем, которые требуют совместной работы нескольких экспертов или систем. Он представляет собой централизованную систему, где различные компоненты могут вносить свои вклады в решение задачи. Доска объявлений позволяет различным компонентам обмениваться информацией и координировать свои действия для достижения общей цели.

## Servant (Слуга)

Паттерн Слуга используется для предоставления общего интерфейса, через который клиенты могут взаимодействовать с группой объектов. Слуга выступает в роли посредника между клиентом и группой объектов, обеспечивая выполнение запросов клиента. Этот паттерн позволяет клиенту работать с группой объектов, не зная о конкретных деталях их реализации.

## State (Состояние)

Паттерн Состояние позволяет объекту изменять свое поведение в зависимости от своего внутреннего состояния. Он представляет собой альтернативу использованию большого количества условных операторов, разбрасывая логику в разные классы состояний. Этот паттерн позволяет упростить код и сделать его более гибким при добавлении новых состояний.

## Strategy (Стратегия)

Паттерн Стратегия позволяет определить семейство алгоритмов, инкапсулировать их и сделать их взаимозаменяемыми. Он позволяет клиенту выбирать алгоритм во время выполнения программы, не привязываясь к конкретным реализациям. Этот паттерн позволяет добиться гибкости и легкости модификации алгоритмов.
